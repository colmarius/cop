$(document).ready(function() {

  module("copContext");

  // Context creation.
  test( "Context: creation", function( ) {
    var context = new copContext( );
    
    equal( context.active, false, "Context should be inactive." );
    equal( context.activationCounter, null, 
          "Context activation counter should be null." );
    equal( context.id, (cop.nextContextId() - 1), 
          "Context id autogenerated." );
    equal( context.adaptedObjects.size(), 0, 
          "Context should have no adapted objects." );
    ok( context.activateEvent, "Context should have an activateEvent." );
    ok( context.deactivateEvent, "Context should have an deactivateEvent." );
    ok( context.adaptEvent, "Context should have an adaptEvent." );
  });
  
  test( "Context: creation with public name", function( ) {
    var context, contextName = "context.public.name";
    
    context = new copContext( contextName );
    equal( context.name, contextName, "Context name given on creation." );
    
    try {
      copContextRegistry.publish( context, contextName );
      ok(false, "Expected to complain about existing published context.");
    } catch( e ) {
      equal( e.toString(), "Context already published under name: " + contextName,
            "Existing published context." );
    }
    
    ok( context === copContextRegistry.retrieve( contextName ), 
        "Published context retrieved correctly.");
  });
  
  test( "Context: creation as anonymous", function( ) {
    var anonymousContext;
    
    anonymousContext = new copContext( );
    equal( anonymousContext.name, "anonymous_" + anonymousContext.id ,
          "Context published without name is anonymous." );
    
    anonymousContext = new copContext( "" );
    equal( anonymousContext.name, "anonymous_" + anonymousContext.id , 
          "Context published with empty name is anonymous." );
  });

  test( "Context: activate, deactivate", function( ) {
    var context = new copContext( );
    
    equal( context.active, false, "Context should be inactive." );
    context.activate( );
    equal( context.active, true, "Context should be active." );
    ok( context.activationCounter, "Context should have activationCounter." );
    context.deactivate( );
    equal( context.active, false, "Context should be inactive." );
    equal( context.activationCounter, null, 
          "Context activationCounter should be null." );
          
    // TODO: with adapted objects
    
  });
  
  test( "Context: adapt, unadapt", function( ) {
    var context = new copContext( ),
        object = { toString: function() { return "original"} },
        trait = Trait({ toString: function() { return "adapted-1"; }}),
        trait2 = Trait({ toString: function() { return "adapted-1"; }});
    
    equals( context.adaptedObjects.size(), 0, "Context has no adapted objects" );
    equals( context.adaptedObjects.containsKey( object ), false, 
            "Object not previously adapted" );
    context.adapt( object, trait );        
    equals( context.adaptedObjects.containsKey( object ), true,
            "Object now has adaptation" );
    ok( context.adaptedObjects.get( object ) === trait, 
        "Object adapted by trait" );  
    context.adapt( object, trait2 );    
    equals( context.adaptedObjects.containsKey( object ), true,
            "New request for object adaptation" );
    ok( context.adaptedObjects.get( object ) !== trait2, 
        "Object does not have new adaptation" );
    ok( context.adaptedObjects.get( object ) === trait, 
        "Object has old adaptation" );
        
    context.unadapt( object );
    equals( context.adaptedObjects.containsKey( object ), false, 
            "Object now has no adaptation" );
  });
  
  test( "Context: adapt object with more traits", function( ) {
    var context = new copContext( ),
        object = { toString: function() { return "original"} },
        trait = Trait({ toString: function() { return "adapted-1"; }}),
        trait2 = Trait({ toString: function() { return "adapted-2"; }}),
        trait3 = Trait({ toString: function() { return "adapted-3"; }}),
        object2 = { a:1, b:2 },
        traitFoo = Trait({ foo: function() { return "foo"; } }),
        traitBar = Trait({ bar: function() { return "bar"; } });
        
    try {
      context.adapt( object, trait, trait2, trait3 );
      ok( false, "Should throw an error: traits are conflicting" );
    } catch( e ) {
      equal( e.toString(), "Error: Remaining conflicting property: toString", 
            "Adapting object with three traits which are in conflict" );
    }
    try {
      context.adapt( object2, traitFoo, traitBar );
      ok( true, "Adapting object with two traits" );
    } catch( e ) {
      ok( false, "Should not throw an error" );
    }
  });
  
  test( "Context: markTrait", function( ) {
    var context = new copContext( "C" ),
        trait = new Trait({ foo: function() {} });
    
    context.markTrait( trait );
    
    for( var name in trait ) {
      ok( trait[name].context === context, 
          "Marked trait properties has reference to adapting context" );
    }
  });
  
  test( "Context: setTrait, getTrait", function( ) {
    var context = new copContext( ), object = {}, 
        trait = Trait({ foo: function(){} });
    
    context.setTrait( object, trait );
    
    ok( context.getTrait( object ) === trait, "Stored trait retrieved correctly" );
    
    // TODO: more detailed tests:
    // - traits which are in conflitct
  });
  
  // TODO: activate/deactivate with adapted objects
  
});
